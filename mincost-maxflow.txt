struct edge {
	int w, f, c, cost;
	int inv;
	edge(){};
	edge(int _w, int _f, int _c, int _cost, int _inv) {
		w = _w;
		f = _f;
		c = _c;
		cost = _cost;
		inv = _inv;
	}
};

int cnt;
vector<vi> g(MAXN);
vector<edge> edges;

void add_edge(int v, int w, int flow, int cost) {
	edges.push_back(edge(w, 0, flow, cost, cnt + 1));
	edges.push_back(edge(v, 0, 0, -cost, cnt));
	g[v].push_back(cnt);
	g[w].push_back(cnt + 1);
	cnt += 2;
}

deque<int> q;
int fstart, fend, d[MAXN], par[MAXN], parid[MAXN];
bool used[MAXN];

bool find_way() {
	int eid, from, to;
	q.clear();
	q.push_back(fstart);
	forn(i, fend + 1)
		d[i] = INF;
	memset(used, 0, sizeof(used));
	d[fstart] = 0;
	par[fstart] = -1;
	used[fstart] = 1;

	while (!q.empty()) {
		from = q.front();
		used[from] = 0;
		q.pop_front();

		forn(i, g[from].size()) {
			eid = g[from][i];
			to = edges[eid].w;
			if (edges[eid].c - edges[eid].f > 0 && d[from] + edges[eid].cost < d[to]) {
				d[to] = d[from] + edges[eid].cost;
				par[to] = from;
				parid[to] = eid;
				if (!used[to])
					q.push_back(to);
				used[to] = 1;
			}
		}
	}

	return (d[fend] < INF);
}

int fflow, fcost, answer;

void get(int v) {
	if (par[v] == -1)
		return;

	fflow = min(fflow, edges[parid[v]].c - edges[parid[v]].f);
	get(par[v]);
	fcost += edges[parid[v]].cost;
	edges[parid[v]].f += fflow;
	edges[edges[parid[v]].inv].f -= fflow;
}

<...>

cnt = 0;
fstart = ...;
fend = ...;

answer = 0;
while (find_way()) {
	fflow = INF;
	fcost = 0;
	get(fend);
	answer += fcost;
}